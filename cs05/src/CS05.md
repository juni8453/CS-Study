### `프로세스 메모리 구조`

![스크린샷 2022-01-17 오후 3.22.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec8ececa-5f3d-44e6-9ebe-08c16e182b57/스크린샷_2022-01-17_오후_3.22.17.png)

1. 프로세스를 구성하는 메모리는 `4가지` 이다.
    - `코드(Code)` 영역
        - 기계어로 번역된 소스코드가 저장되는 영역
        - CPU는 이 영역에서 명령어를 하나씩 가져와 처리하게 된다.
        - `컴파일` 시 영역이 결정되고 중간에 코드를 바꿀 수 없게 Read-Only 로 되어있다.

    - `데이터(Data)` 영역
        - `전역 변수, 정적(Static) 변수` 가 저장되는 영역
        - 이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸된다.
        - `컴파일` 이 완료되면 전역, 정적 변수를 참조한 코드는 데이터 영역의 주소값을 가리키도록 바뀐다.

    - `힙(Heap)` 영역
        - 프로그래머에 의해 메모리가 동적으로 관리되는 영역
        - `런타임` 에 크기가 결정되는 메모리 영역
        - 메모리 주소 값에 의해서만 참조되고 사용되는 영역
        - 자바에서는 객체가 힙 영역에 생성되고 가비지 컬렉터에 의해 정리된다.
        - 낮은 주소에서 높은 주소 방향으로 메모리를 할당 (Row → High)

    - `스택(Stack)` 영역
        - 코드 블럭 {} 내의 지역변수나 매개변수가 저장되는 영역
        - 해당 블럭을 벗어나면 해제되는 특성이 있다.
        - 함수의 수행을 마치고 복귀할 주소 및 데이터 (지역, 매개변수, 리턴값 등) 을 임시로 저장한다.
        - 프로세스가 메모리에 로드될 때 스택 사이즈가 고정되어 있어 `런타임 시 스택 사이즈를 바꿀 수 없다`
        - `컴파일` 시 스택 메모리의 최대 크기가 결정되고, 이를 초과할 경우 `Stack overflow` 가 발생한다.
        - 높은 주소에서 낮은 주소 방향으로 메모리를 할당한다. (High → Row)

    1. 힙(Heap) 과 스택(Stack)
        - 사실 힙과 스택은 같은 공간을 공유한다.
        - 힙이 메모리의 낮은 주소부터 할당되면, 스택은 높은 주소부터 할당되는 식이다.
        - 같은 공간을 공유하기 때문에 상대 공간을 침범하는 일이 발생할 수 있다.
        - 이를 각각 `Stack overflow`, `Heap overflow` 라고 한다.


    ---
    
    ### `JVM 메모리 구조`
    
    - 내용 출처
    
    [JVM 메모리 구조란? (JAVA)](https://steady-coding.tistory.com/305)
    
    [자바의 실행 과정](https://velog.io/@pond1029/JVM)
    
    [[Java-3] JVM과 JIT 컴파일러란?](https://catch-me-java.tistory.com/11)
    
    [JVM 메모리 구조란? (JAVA)](https://steady-coding.tistory.com/305)
    
    1. JVM 이란?
        - 자바 가상 머신 (Java Virtual Machine) 으로 자바 바이트 코드를 실행할 수 있는 주체이다.
        - 자바 프로그램 파일을 운영체제, CPU 종류에 무관하게 실행이 가능하게 해준다.
        - 즉, JVM 은 운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당
            
            운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다.
            
        - 자바 어플리케이션은 `운영체제에 독립적인가 종속적` 인가 ?
            
            ![스크린샷 2022-01-18 오후 4.50.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/610c7955-cae8-4983-a16a-10372753c6c2/스크린샷_2022-01-18_오후_4.50.37.png)
            
            - 위 그림에서 보다시피 일반 어플리케이션과 자바 어플리케이션의 차이는 JVM 에 있다.
            - 다른 어플들은 운영체제와 바로 붙어있기 때문에 운영체제에 종속적인데, 자바는 JVM 이
                
                운영체제와 프로그램 사이에서 해당 운영체제에 맞게 변환하여 전달하기 때문에 운영체제에
                
                자유롭다고 할 수 있다. (자바 어플은 운영체제에 종속되지 않는 특징)
                
            - 하지만 `자바 어플이 아닌 JVM은 운영체제에 종속적` 이기 때문에 운영체제마다 알맞는
                
                JVM이 필요하다.
                
    
    1. 자바 프로그램 실행 과정
        
        ![스크린샷 2022-01-18 오후 3.18.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc3d16f7-d637-46c9-85eb-d98e755a3e34/스크린샷_2022-01-18_오후_3.18.17.png)
        
        - 자바 컴파일러를 통해 자바 클래스 파일 `(.java)` 를 자바 바이트코드 `(.class)` 로 변환한다.
        - 변환된 바이트 코드를 JVM 에서 읽어 들이고 어떤 운영체제든지 실행할 수 있도록 만든다.
    
    1. JVM 의 구조
        
        ![스크린샷 2022-01-18 오후 3.12.30.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05170926-a3ae-4177-9710-bb56a77e4280/스크린샷_2022-01-18_오후_3.12.30.png)
        
        - JVM 은 크게 `4가지 구조` 로 나눌 수 있다.
        - 자바 파일은 자바 컴파일러에 의해 바이트 코드 형태인 클래스 파일로 변환된다. 그리고 이 클래스
            
            파일은 클래스 로더가 읽어들이면서 JVM 이 수행된다.
            
        - `바이트 코드` (Byte Code) 란 ?
            - 바이트 코드란 가상 컴퓨터에서 작동하도록 만든 이진코드이다.
            - `JVM 이 이해할 수 있는 언어로 변환된 코드` 이며, 명령어의 크기가 1 Byte 라서 자바 바이트
                
                코드라고 불린다.
                
            - 자바 코드를 배포하는 가장 작은 단위이고 확장자는 `.class` 이다.
            - 컴파일러의 버전과 JVM 버전이 다르면 컴파일 된 바이트 코드가 실행되지 않을 수도 있는데,
                
                상위 버전에서 컴파일한 바이트 코드는 하위 버전에서 실행하지 못하지만 컴파일 옵션으로
                
                해결할 수 있다 !
                
        - `Class Loader` (클래스 로더)
            - 생성된 클래스 파일을 엮어서 JVM 이 운영체제로부터 할당받은 메모리 영역인
                
                `Runtime Data Area` 로 적재하는 역할을 수행하는 모듈이다.
                
            - 자바 애플리케이션이 실행 중 (런타임) 일 때 이런 작업이 수행된다.
            
        - `Runtime Data Area`
            - Class Loader 에 의해 적재된 클래스 파일들을 보관하는 영역이다.
            - 즉, JVM 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
            - 이 영역을 세분화하자면 `6개의 영역` 으로 나눌 수 있다.
                - Method Area
                    - Code Area, Static Area 등으로 불리어지는 영역이다.
                    - 모든 쓰레드가 공유하는 메모리 영역이다.
                    - 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관한다.
                    
                - Stack Area
                    - 호출된 메소드의 매개, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.
                    - 힙 영역의 객체를 참조할 수 있는 참조변수를 저장한다.
                    - 메소드 하나가 호출될 때마다 새 프레임이 생성되어 스택에 쌓이고, 메소드 호출이 정상
                        
                        완료되거나 예외가 던져지면 프레임은 스택에서 빠지며 소멸된다.
                        
                    - 또한 쓰레드가 종료되면 스택도 제거된다.
                    
                - Heap Area
                    - 인스턴스화 된 모든 클래스 인스턴스와 배열, 객체를 저장한다. `new 연산자`
                    - GC를 통해 메모리 반환이 일어난다.
                    
                - Native Method Area
                    - 자바 외의 다른 언어에서 제공되는 메소드들이 저장되는 영역이다.
                    - 보통 C/C++ 등의 코드를 수행하기 위한 스택이다.
                    
                - PC Register
                    - 쓰레드가 생성될 때마다 생성되는 영역으로, 쓰레드가 어떠한 명령을 실행하게 될지에
                        
                        대한 부분을 기록하는 곳이다.
                        
                - Garbage Collection
                    - 참조되지 않은 객체들을 탐색 후 삭제한다.
                    - 자세한 건 4. `Garbage Collector` 부분을 참조
            
        - `Execution Engine` (실행 엔진)
            - Class Loader 를 통해 JVM 내의 Runtime Data Area 에 배치된 바이트 코드들을 기계어로변경하고, 명령어 단위로 읽어서 실행하는 모듈이다.
            - 실행 엔진은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하는데,
                
                이 때 두 가지 방식을 혼합해서 사용하게 된다.
                
                - `Interpreter` 방식
                    1. 바이트 코드를 한 줄씩 해석, 실행하는 방식이다.
                    2. 초기 방식으로, 한 줄씩 해석하고 실행하기 때문에 속도가 느리다는 단점이 있다.
                - `JIT 컴파일` 방식
                    
                    ![스크린샷 2022-01-18 오후 4.21.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3166c34f-1531-4c4c-b83c-ed1b39fb2d6f/스크린샷_2022-01-18_오후_4.21.48.png)
                    
                    ![정확히는 번역 안할래 ~ 보단 Interpreter 가 안 읽어도 된다고 생각하는게 옳다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2838e9a7-1bac-47d4-b1f3-1c5b94a1ebb7/스크린샷_2022-01-18_오후_4.22.01.png)
                    
                    정확히는 번역 안할래 ~ 보단 Interpreter 가 안 읽어도 된다고 생각하는게 옳다.
                    
                    1. Interpreter 방식의 단점을 보완하기 위해 나온 실행 방식이다.
                    2. Interperter 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여
                        
                        네이티브 코드로 변경하고, 이후에는 네이티브 코드로 직접 실행하는 방식이다.
                        
                    3. JIT 컴파일러는 같은 코드를 매번 해석하지 않고, 실행할 때 컴파일을 하면서 해당
                        
                        코드를 캐싱해버린다. 이후에는 바뀐 부분만 컴파일하고, 나머지는 캐싱된 코드를
                        
                        사용한다. (Interpreter 방식보다 빠른 이유)
                        
                - 왜 두 가지 방식을 혼합해 실행하나 ?
                    
                    위의 JIT 컴파일 방식만 봤을 때, Interpreter 방식 보다 장점만 있는 것 같지만 아니다.
                    
                    `JIT 컴파일` 방식으로 바이트 코드를 네이티브 코드로 변환하는데도 많은 비용이 소모되고
                    
                    바이트 코드를 `인터프리팅` 하는 것 보다 훨씬 오래 걸린다. 그러니까 굳이 한 번만 실행되는
                    
                    코드를 굳이 `JIT 컴파일` 방식을 이용해서 실행하는 것은 배보다 배꼽이 커지는 것이다.
                    
                    따라서 `JIT 컴파일` 방식을 사용하는 JVM 들은 내부적으로 해당 메서드가 얼마나 자주
                    
                    수행되는지 체크하고, 일정 정도를 넘어설 때에만 `JIT 컴파일` 을 수행한다.
                    
                
        - `Garbage Collector` (가비지 컬렉터)
            - 내용 출처
            
            [NAVER D2](https://d2.naver.com/helloworld/1329)
            
            [JVM의 GC동작, 몇 종류의 GC](https://smjeon.dev/etc/jvm-gc/)
            
            - GC 의 기능
                - 동적으로 할당한 메모리 영역 중 사용하지 않는 영역을 탐지하여 해제하는 기능을 지닌다.
                - 즉, `Heap 영역` 에 생성된 자바의 객체는 사용되지 않는다면 GC에 의해 제거된다.
                
            - GC 코드 예시
                
                ```java
                public class Main {
                	public static void main(String[] args) {
                		int num1 = 10;
                		int num2 = 5;
                		String name = "Tany";
                		int sum = num1 + num2;
                
                		System.out.println(sum);
                		System.out.println(name);
                }
                
                name              -> String Tany 
                sum = 15          
                num2 = 5          
                num1 = 10         
                
                stack 영역             heap 영역
                
                stack 영역에 지역변수가 쌓이고 String 은 객체 타입이기 때문에 String을 참조할 수 있는
                name 변수가 스택에 생성되면서 heap 영역의 String Tany 를 가리키게 된다.
                
                여기서 main()이 종료되면 ?
                
                                     String Tany 
                
                         
                
                stack 영역             heap 영역
                
                스택 영역의 데이터와 String을 참조할 수 있는 포인터 또한 지워진다.
                그리고 heap 영역에 String 객체가 남게된다.
                이런 객체를 Unreachable Object (연결할 수 없는 객체) 라고 하며 GC의 대상이 된다.
                ```
                
            - GC 과정
                - GC 가 실행된다고 하면 다음의 2가지 공통적인 단계를 따르게 된다.
                1. `Stop The World`
                    
                    Stop The World 는 GC 를 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다.
                    
                    GC 가 실행될 때는 GC 를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC 가
                    
                    완료되면 다시 다른 쓰레드가 실행되며 작업이 재개된다.
                    
                2. `Mark and Sweep`
                    
                    
                    | Mark | 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업 |
                    | --- | --- |
                    | Sweep | Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업 |
                    
                    Stop The World 를 통해 모든 작업을 중단시키면, GC 는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참고하는지를 탐색하게 된다.
                    
                    이후 사용되고 있는 메모리를 식별하는데, 이러한 과정을 `Mark` 라고 한다.
                    
                    이후 Mark 단계에서 사용되지 않음으로 식별된 메모리를 `Sweep` 작업으로 해제한다.
                    
            - GC 는 언제 실행될까 ?
                
                GC 가 언제 실행되는지 알기 위해선 Heap 영역에 대해 알 필요가 있다.
                
                Heap 영역은 `Young Generation` 과 `Old Generation` 영역 2가지로 나눌 수 있는데, 여기서 또 `Young Generation` 영역은 3가지 영역으로 나눠진다.
                
                1. `Eden` - 새로 생성된 객체가 할당되는 영역
                2. `Survivor 1,2` - 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
                
                ![스크린샷 2022-01-17 오후 5.39.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02646a2e-517a-47c2-9c4e-c56ac97feaaf/스크린샷_2022-01-17_오후_5.39.48.png)
                
                `Young Generation` 영역의 동작 순서
                
                1. 새로 생성된 객체가 `Eden` 영역에 할당된다.
                2. 객체가 계속 생성되어 `Eden` 영역이 꽉 차게되면 `Minor GC` 가 실행된다.
                    - `Eden` 영역에서 살아남은 객체는 1개의 `Survivor A` 영역으로 이동된다.
                    - 이 과정이 반복되다보면 `Survivor` 영역 하나가 가득차게 된다.
                        
                        ![스크린샷 2022-01-17 오후 6.24.14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08b2276d-223c-4a57-8fe1-0b4d85c02b71/스크린샷_2022-01-17_오후_6.24.14.png)
                        
                        ![스크린샷 2022-01-17 오후 6.26.53.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/50f2dc3b-fb10-45c7-bca7-5f3d318b5e99/스크린샷_2022-01-17_오후_6.26.53.png)
                        
                        ![스크린샷 2022-01-17 오후 6.25.39.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0a80f13-50ae-44a5-bcd1-ab41c7ac5a24/스크린샷_2022-01-17_오후_6.25.39.png)
                        
                    
                3.  `Survivor A` 영역이 가득 차면 다른 `Survivor` 영역으로 살아남은 객체를 이동시킨다.
                    
                    ![스크린샷 2022-01-17 오후 6.27.19.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5208732f-5861-4f9c-bf3a-baea479ce18a/스크린샷_2022-01-17_오후_6.27.19.png)
                    
                    - 이렇게 되면 처음 A 영역은 아무 데이터도 없는 상태가 된다. 즉, 한 `Survivor` 영역은
                        
                        반드시 빈 상태가 되는 것이다.
                        
                    - 이때 서바이벌에서 다른 서바이벌 영역으로 이동한 객체는 `Age` 값이 증가한다.
                    
                4. 1 ~ 3번 과정을 반복한다.
                    
                    
                5. 객체의 `Age` 값이 특정 값 이상이 되면 `Promotion` 이라고 하는 것이 일어난다.
                    
                    ![스크린샷 2022-01-17 오후 6.27.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/807d15b8-3baf-40d0-a45a-1efb4dda3be5/스크린샷_2022-01-17_오후_6.27.47.png)
                    
                    - `Promotion` 은 특정 `Age` 이상의 객체를 Young → Old 영역으로 옮기는 것을 말한다.
                    
                6. `Promotion` 이 실행되며 Old 영역이 가득차면 `Major GC` 가 발생한다.
                    
                    ![스크린샷 2022-01-17 오후 6.28.07.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adc3a283-a527-44e0-87de-0b4d505bcd2c/스크린샷_2022-01-17_오후_6.28.07.png)
                    
                
            - Minor GC 와 Major GC
                
                `Minor GC` - Young Generation 영역 담당
                
                `Major GC` - Old Generation 영역 담당
                
                | GC 종류 | Minor GC | Major GC |
                | --- | --- | --- |
                | 대상 | Young Generation | Old Generation |
                | 실행 시점 | Young 영역이 꽉 찬 경우 | Old 영역이 꽉 찬 경우 |
                | 실행 속도 | 빠르다 | 느리다 |
